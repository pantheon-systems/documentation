---
title: Redirect Incoming Requests
description: Learn to redirect requests to an alternate Drupal or WordPress domain name or path via PHP.
category:
  - going-live
  - managing
keywords: redirect, redirect request, redirect requests to another domain, redirect requrests to another path, redirect incoming requests, redirects, .htaccess, nginx, settings.php, wp-config.php, redirect via php, php redirect, php redirects,
---
It's often useful to redirect requests to a different domain or path. While it's technically possible to use Drupal or WordPress to perform the redirect, it's faster and more efficient to redirect without having to fully bootstrap your web application.  


<div class="alert alert-info" role="alert">
<h4>Note</h4>
Drupal sites on Pantheon technically do not require a <code>sites/default/settings.php</code> file to run, and depending on how your site was created it might not have one. If it's missing, just create an empty PHP file and proceed. For more information on settings.php and environment logic, see <a href="/docs/articles/drupal/configuring-settings-php">Configuring settings.php</a>.</div>

#### Why redirect with settings.php or wp-config.php and not .htaccess?

Pantheon uses nginx webservers for optimal performance. While completely compatible with Drupal or WordPress, nginx does not recognize or parse Apache's directory-level configuration files, known as .htaccess files. Instead, redirect logic should be stored in the site's settings.php for Drupal or wp-config.php for WordPress.  

Using settings.php or wp-config.php for redirects has a number of advantages. First, as it's executable code with application state awareness, logic and decisions can be made that a web server would have no context for. Conditional logic, regular expressions, and much more are possible.  

Configuration also tends to be more maintainable as Drupal and WordPress developers are typically literate in PHP, but very few people are naturally fluent in Apache2 rewrite rules and conditions.

Finally, as settings.php or wp-config.php is parsed very early in the bootstrap process, redirects like this are "cheap", meaning low overhead. If you use a 301 redirect, Varnish will cache it as well.

<div class="alert alert-info" role="alert">
<h4>Note</h4>
Automatic resolution of domains is not supported. For each domain that you want to resolve to Pantheon, add a hostname with a matching record to an environment on the <a href="/docs/articles/sites/domains#step-2-add-domains-to-the-site-environment" data-proofer-ignore> site's Dashboard</a>.</div>


## Redirect to a Common Domain

While it’s good for visitors and DNS to resolve both www and the domain itself, it's best practice to choose one or the other and redirect from www to non-www (or vice versa, your call). This optimizes SEO by avoiding duplicate content and prevents session strangeness, where a user can be signed on one domain but logged out of other domains at the same time.

Pantheon's www-redirection service automatically redirects requests to the www subdomain as long as <a href="/docs/articles/sites/domains/#step-3-configure-your-dns" data-proofer-ignore>DNS has been configured</a> appropriately. However, this service does not apply to sites with HTTPS enabled and the following block should be used to standardize on www:

```
// Require WWW.
if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
  $_SERVER['PANTHEON_ENVIRONMENT'] === 'live') {
  if ($_SERVER['HTTP_HOST'] == 'yoursite.com' ||
      $_SERVER['HTTP_HOST'] == 'live-yoursite.pantheon.io') {
    header('HTTP/1.0 301 Moved Permanently');
    header('Location: http://www.yoursite.com'. $_SERVER['REQUEST_URI']);
    exit();
  }
}
```



If you prefer to use the bare domain, use the following code block and run your DNS settings through a service that supports CNAME flattening. For details, see <a href="/docs/articles/sites/domains/#step-3-configure-your-dns" data-proofer-ignore>Domains and DNS</a>.

<div class="alert alert-info" role="alert">
<h4>Note</h4>
If you are running the site on a Pro plan or above with an SSL certificate, use the snippet below without configuring a CNAME flattening service. </div>

To direct all traffic to the bare domain using CloudFlare:

 - Sign up for a service that supports CNAME flattening, such as [CloudFlare](https://www.cloudflare.com/).
 - Remove the existing A record generated by CloudFlare, then create CNAME records for www and the bare domain.
 - Add the following snippet to your settings.php or wp-config.php:

 ```
    // Redirect all traffic to non-www. For example yoursite.com
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
      $_SERVER['PANTHEON_ENVIRONMENT'] === 'live') {
      if ($_SERVER['HTTP_HOST'] == 'www.yoursite.com' ||
          $_SERVER['HTTP_HOST'] == 'live-yoursite.pantheon.io') {
        header('HTTP/1.0 301 Moved Permanently');
        header('Location: http://yoursite.com'. $_SERVER['REQUEST_URI']);
        exit();
      }
    }
 ```

## Redirect to HTTPS

### Require HTTPS for All Pages
To enable HTTPS across Pantheon's Dev, Test, and Live environments for all traffic on your site (a best practice if you have a certificate), check for the `HTTP_X_SSL` code:

    // Require HTTPS.
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
      $_SERVER['HTTPS'] === 'OFF') {
      if (!isset($_SERVER['HTTP_X_SSL']) ||
        (isset($_SERVER['HTTP_X_SSL']) && $_SERVER['HTTP_X_SSL'] != 'ON')) {
        header('HTTP/1.0 301 Moved Permanently');
        header('Location: https://'. $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);
        exit();
      }
    }


### Require HTTPS for Specific Pages

If you don't want to have your whole site under HTTPS, we recommend using a secure subdomain (e.g. secure.yoursite.com). Mixed-mode secure sessions are vulnerable. There are also edge cases with caching that can create bugs with mixed-mode HTTPS. Putting the secure pages on a secure domain prevents confusion in caching between secure/insecure content.

You can implement a secure domain for a specific set of page with Drupal modules or WordPress plugins, or in settings.php for Drupal or wp-config.php for WordPress. This example enforces a secure domain for any path that begins with `/admin`:

    // Require HTTPS for admin pages.
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
      $_SERVER['HTTPS'] === 'ON') {
      if (!isset($_SERVER['HTTP_X_SSL']) || $_SERVER['HTTP_X_SSL'] != 'ON') {
        // If admin, redirect to secure.
        if (preg_match('/^\/admin/', $_SERVER['REQUEST_URI'])) {
          header('HTTP/1.0 301 Moved Permanently');
          header('Location: https://secure.yoursite.com'. $_SERVER['REQUEST_URI']);
          exit();
        }
      }
    }

### Require HTTPS and Standardize Domain

To use HTTPS everywhere and standardize on your domain (e.g. `www.yoursite.com`), combine this kind of logic into a single block:

    // Require HTTPS, www.
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
      $_SERVER['PANTHEON_ENVIRONMENT'] === 'live') {
      if ($_SERVER['HTTP_HOST'] != 'www.yoursite.com' ||
          !isset($_SERVER['HTTP_X_SSL']) ||
          $_SERVER['HTTP_X_SSL'] != 'ON' ) {
        header('HTTP/1.0 301 Moved Permanently');
        header('Location: https://www.yoursite.com'. $_SERVER['REQUEST_URI']);
        exit();
      }
    }

### Require HTTPS Everywhere Except Specific Pages

To use HTTPS for everything except some specific pages, such as an RSS feed:

    // HTTPS logic.
    $redirect_domain = 'www.yoursite.com';
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) && $_SERVER['PANTHEON_ENVIRONMENT'] == 'live') {
      $redirect_location = '';
      // Do not require HTTPS for specific pages.
      if (in_array($_SERVER['REQUEST_URI'], array('/rss.xml'))) {
        // Check if HTTPS is enabled.
        if (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'ON') {
          $redirect_location = 'http://' . $redirect_domain . $_SERVER['REQUEST_URI'];
        }
      }
      // Require HTTPS for everything else.
      else if (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] != 'ON') {
        $redirect_location = 'https://' . $redirect_domain . $_SERVER['REQUEST_URI'];
      }
      // Perform redirect.
      if ($redirect_location) {
        header('HTTP/1.0 301 Moved Permanently');
        header('Location: ' . $redirect_location);
        exit;
      }
    }

## Redirect to Subdirectories or Specific URLs

To redirect from a subdomain to a specific area of the site, use the following:

    // Redirect subdomain to a specific path.
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
      $_SERVER['HTTP_HOST'] == 'subdomain.yoursite.com') {
      $newurl = 'http://www.yoursite.com/subdomain/'. $_SERVER['REQUEST_URI'];
      header('HTTP/1.0 301 Moved Permanently');
      header("Location: $newurl");
      exit();
    }

This will redirect requests like http://subdomain.yoursite.com/some/path to http://www.yoursite.com/subdomain/some/path.

The same technique works for single subdomain redirects. Just specify the path in `$newurl` without bothering with `$_SERVER['REQUEST_URI']`

## Redirect From One Path to Another

    // 301 Redirect from /old to /new.
    if ($_SERVER['REQUEST_URI'] == '/old') {
      header('HTTP/1.0 301 Moved Permanently');
      header('Location: /new');
      exit();
    }

## Redirect Multiple Subdomains to a Single Domain

    // Redirect multiple subdomains to a single domain.
    if (isset($_SERVER['PANTHEON_ENVIRONMENT']) &&
      $_SERVER['PANTHEON_ENVIRONMENT'] === 'live') {
      if (in_array($_SERVER['HTTP_HOST'], array(
        'sub1.youroldwebsite.com',
        'sub2.youroldwebsite.com',
        'sub3.youroldwebsite.com',
        'sub4.youroldwebsite.com',
        'sub5.youroldwebsite.com',
      ))) {
        header('HTTP/1.0 301 Moved Permanently');
        header('Location: http://main.yournewwebsite.com'. $_SERVER['REQUEST_URI']);
        exit();
      }
    }

## Redirect Legacy UNIX-Style User Home Folder Paths

When transitioning from a system that used a tilde to indicate a home directory, the syntax is slightly different. Here's how you can parse out the username and relative path that the request was made for:

    $request_parts = explode('/', $_SERVER['REQUEST_URI']);
    $legacy_username = $legacy_path = '';
    if (isset($request_parts[1]) && strpos($request_parts[1], '~') === 0) {
      $legacy_username = substr($request_parts[1], 1);
      // If FALSE, then the request was just to the username.
      $legacy_path = substr($_SERVER['REQUEST_URI'], (strlen($request_parts[1]) + 1));
    }
    if ($legacy_username) {
      // Your custom logic.
    }
